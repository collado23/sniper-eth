import os, time, redis, json
import pandas as pd
from binance.client import Client

# --- üß† 1. MEMORIA DE CAPITAL Y ROI (Redis) ---
r_url = os.getenv("REDIS_URL")
r = redis.from_url(r_url) if r_url else None

def gestionar_memoria(leer=False, datos=None):
    capital_inicial = 15.77
    if not r: return capital_inicial, []
    
    historial = r.lrange("historial_bot", 0, -1)
    
    if leer:
        if not historial: return capital_inicial, []
        # Sumamos todos los ROIs guardados para saber el capital actual
        roi_acumulado = sum(json.loads(t).get('roi', 0) for t in historial)
        horas_malas = [json.loads(t).get('h') for t in historial if json.loads(t).get('res') == "LOSS"]
        capital_actual = capital_inicial + (capital_inicial * (roi_acumulado / 100))
        return capital_actual, list(set(horas_malas))
    else:
        # Guardamos el ROI real del trade para que la memoria sea exacta
        r.lpush("historial_bot", json.dumps({
            'm': datos['m'], 'roi': datos['roi'], 
            'res': datos['res'], 'h': time.strftime('%H'),
            'p_ent': datos.get('p_ent'), 'p_sal': datos.get('p_sal')
        }))

# --- üìä 2. AN√ÅLISIS T√âCNICO PRO (EMAs + RSI + ROI) ---
def analizar_mercado(simbolo, cliente):
    try:
        # Traemos 100 velas para que las EMAs sean precisas
        klines = cliente.get_klines(symbol=simbolo, interval='5m', limit=100)
        df = pd.DataFrame(klines, columns=['time','open','high','low','close','vol','etc1','etc2','etc3','etc4','etc5','etc6'])
        df['close'] = df['close'].astype(float)

        # A. LAS EMAs (El cruce de tendencia)
        ema_rapida = df['close'].ewm(span=9, adjust=False).mean().iloc[-1]
        ema_lenta = df['close'].ewm(span=21, adjust=False).mean().iloc[-1]

        # B. RSI (Psicolog√≠a de p√°nico/euforia)
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rsi = 100 - (100 / (1 + (gain / loss))).iloc[-1]

        # C. DETECTOR DE DESPLOME (Modo Cocodrilo)
        precio_actual = df['close'].iloc[-1]
        caida = ((precio_actual - df['close'].iloc[-5]) / df['close'].iloc[-5]) * 100

        # --- L√ìGICA DE DECISI√ìN COMPLETA ---
        
        # Condici√≥n Cocodrilo: Desplome + RSI bajo + Cruce de EMAs empezando
        if caida < -2.0 and rsi < 30:
            if ema_rapida > ema_lenta * 0.99: # Filtro para asegurar que no siga cayendo al infinito
                return True, f"üêä ATAQUE! Ca√≠da: {caida:.1f}% | RSI: {rsi:.1f} | EMA 9/21 lista"

        return False, f"Acechando... EMA9: {ema_rapida:.2f} | RSI: {rsi:.1f}"
    except:
        return False, "Error de an√°lisis"

# --- üöÄ 3. CONFIGURACI√ìN DE PODER (Apalancamiento) ---
APALANCAMIENTO = 10 # 10x para mover tus $15.77 como si fueran $157

# --- üèÅ 4. EJECUCI√ìN MAESTRA ---
cap_real, bloqueos = gestionar_memoria(leer=True)
print(f"ü¶Å BOT MAESTRO V87 ACTIVADO")
print(f"üí∞ CAPITAL REAL: ${cap_real:.2f} | APALANCAMIENTO: {APALANCAMIENTO}x")

presas = ['BTCUSDT', 'XRPUSDT', 'SOLUSDT', 'ETHUSDT', 'PEPEUSDT']

while True:
    h = int(time.strftime('%H'))
    if h in bloqueos:
        print(f"‚è≥ Hora {h} bloqueada por precauci√≥n. El Cocodrilo no muerde aqu√≠.")
        time.sleep(600); continue

    for p in presas:
        puedo, razon = analizar_mercado(p, Client())
        print(f"üßê {p}: {razon} | Cap: ${cap_real:.2f}", end='\r')
        
        if puedo:
            print(f"\nüöÄ [MORDER] Entrando en {p} con {APALANCAMIENTO}x")
            # Simulamos un trade para la memoria (esto lo hace el bot solo despu√©s de operar)
            # datos_trade = {'m': p, 'roi': 2.5, 'res': 'WIN'} 
            # gestionar_memoria(False, datos_trade)
            
    time.sleep(15)
